CREATE DATABASE company_repository;

DROP TABLE company_2 CASCADE;
DROP TABLE contact CASCADE;
DROP TABLE employee CASCADE;
DROP TABLE company_2;

CREATE TABLE company_storage.company_2
(
    id   INT PRIMARY KEY,
    name VARCHAR(128) UNIQUE,
    date DATE NOT NULL CHECK (date > '1995-01-01' AND DATE < '2020-01-01')
    --MOZNA TEZ W TAKI SPOSOB UNIQUE(name, date)
);

-- constrains - ograniczaja wstawieie do db
-- NOTNULL - nie mozna wstawic pustego
-- UNIQUE
-- CHECK(warunek)
-- PRIMARY KEY == UNIQUE + NOT NULL(primary key is single)
-- FOREIGN KEY


INSERT INTO company_2(id, name, date)
VALUES (1, 'Google', '2001-01-01'),
       (2, 'Apple', '2002-10-29'),
       (3, 'Facebook', '1998-10-05');

INSERT INTO company_2(id, name, date)
VALUES (4, 'Amazon', '2005-06-17');

CREATE TABLE employee
(
    id         SERIAL PRIMARY KEY,                              --TYP SERIAL - AUTOMATYCZNA INKREMENTACJA
    --lepsze rozwiazanie id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY
    first_name VARCHAR(128) NOT NULL,
    last_name  VARCHAR(128) NOT NULL,
    company_id INT REFERENCES company_2 (id) ON DELETE CASCADE, --referencja do innej tablicy (SET NULL/DEFAULT, RESTRICT, NO ACTION)
    salary     INT,
    UNIQUE (first_name, last_name)
    --FOREIGN KEY (company_id) REFERENCES company_2(id) - a mozna w taki sposob
);

INSERT INTO employee(first_name, last_name, salary, company_id)
VALUES ('Ivan', 'Sidorov', 500, 1),
       ('Ivan', 'Ivanov', 1000, 2),
       ('Arni', 'Paramonov', NULL, 2),
       ('Petr', 'Petrov', 2000, 3),
       ('Sveta', 'Svetikova', 1500, NULL);


CREATE TABLE contact
(
    id     INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    number VARCHAR(128) NOT NULL,
    type   VARCHAR(128)
);

INSERT INTO contact (number, type)
VALUES ('234-56-78', 'домашний'),
       ('987-65-43', 'рабочий'),
       ('565-25-91', 'мобильный'),
       ('332-55-67', NULL),
       ('465-11-22', NULL);

CREATE TABLE employee_contact
(
    employee_id BIGINT REFERENCES employee (id),
    contact_id  BIGINT REFERENCES contact (id),
    PRIMARY KEY (employee_id, contact_id)
);

INSERT INTO employee_contact (employee_id, contact_id)
VALUES (1, 1),
       (1, 2),
       (2, 2),
       (2, 3),
       (3, 4),
       (4, 5);



SELECT id,
       first_name f_name, --f_name jako alias dla nagłowka
       salary AS  sal     --inny sposob dac alias
FROM employee
ORDER BY first_name,
         salary --(sortowanie rosnąco) -najpierw sortowanie po imieniu, pozniej po salary jezeli imiona takie same
--ORDER BY salary DESC (MALEJĄCO)
LIMIT 3 OFFSET 1; --POMIN 1(OFFSET) I POKAZ TYLKO 3(LIMIT)


SELECT DISTINCT first_name f_name --tylko unikatowe
FROM employee;



SELECT id,
       first_name AS f_name,
       last_name,
       salary
FROM employee
WHERE salary > 1200
  AND first_name != 'Ivan' --filtracja
ORDER BY salary;
--WHERE salary BETWEEN 1000 AND 1500 -- pomiedzy tym a tym
--WHERE salary IN (1000, 1500, 2000) -- SALARY = TYM WARTOSCIOM
-- WHERE salary IN (1000, 1100, 2000)
--    OR (first_name LIKE 'Iv%'
--     AND last_name ILIKE '%ov%')
-- ORDER BY first_name, salary DESC;
-- > < >= <= = !=
-- BETWEEN
-- LIKE (ILIKE) %                AND - OR
-- IN
--WHERE salary IS NULL;


SELECT id,
       first_name AS f_name,
       last_name,
       salary
FROM employee
WHERE first_name LIKE 'Iv%'
  AND last_name ILIKE '%ov' --imie zaczyna sie z Iv a nazwisko konczy sie na ov
ORDER BY salary;

SELECT sum(salary) --avg(average), min, max
--upper/lower(first_name)
FROM employee;

SELECT count(*) --LICZY ILOSC LINIJEK W TABELE
FROM employee;


SELECT concat(first_name, ' ', last_name) AS fio --połaczenie kilka kolumn
--lub to samo co first_name || ' ' last_name AS fio
FROM employee;

SELECT first_name, salary
FROM employee
WHERE salary > 1500
UNION
--połaczenie dwoch polecen (UNION_ALL zachowuje powtarające się  linijki)
SELECT first_name, salary
FROM employee
WHERE last_name LIKE 'Ni%';


SELECT avg(empl.salary)
FROM (SELECT *
      FROM employee
      ORDER BY salary
      LIMIT 3) AS empl; --srednia z salary 3 najnizej opłacalnych pracownikow


SELECT *,
       (SELECT max(salary) FROM employee) - salary AS diff
FROM employee; --pokaz całą tablice oraz roznice max salary z salary kazdego pracownika


SELECT *
FROM employee
WHERE company_id IN (SELECT id FROM company_2 WHERE date > '2000-01-01')
ORDER BY salary DESC;


DELETE
FROM employee
WHERE salary = (SELECT min(salary) FROM employee);


UPDATE employee
SET company_id = 2,
    salary     = 15000
WHERE first_name LIKE 'Kris%'
RETURNING *; --ZWRACA ZMIENIONĄ LINIJKE

SELECT *
FROM employee;



SELECT employee.first_name || ' ' || employee.last_name AS fio,
       company_2.name
FROM employee,
     company_2
WHERE employee.company_id = company_2.id;


SELECT employee.first_name || ' ' || employee.last_name AS fio,
       c.name,
       c2.number || ' (' || c2.type || ')'
FROM employee
         JOIN company_2 c ON employee.company_id = c.id
         JOIN employee_contact ec ON employee.id = ec.employee_id
         JOIN contact c2 on ec.contact_id = c2.id;

SELECT *
FROM company_2
         CROSS JOIN (SELECT count(*)
                     FROM employee) t;


SELECT c.name                             company_name,
       e.first_name || ' ' || e.last_name fio
FROM company_2 c --left join oznacza, ze wszystkie wpisy z lewej tablicy (c) mają sie pojawic w wyniku selectu
         LEFT JOIN employee e ON c.id = e.company_id;

SELECT c.name                             company_name,
       e.first_name || ' ' || e.last_name fio
FROM company_2 c --left join oznacza, ze wszystkie wpisy z lewej tablicy (c) mają sie pojawic w wyniku selectu
         FULL JOIN employee e ON c.id = e.company_id;

-- INNER JOIN (lub JOIN) (nie wypisuje null wartosci)
-- CROSS JOIN (iloczyn kartezjański)
-- LEFT OUTER JOIN (left join oznacza, ze wszystkie wpisy z lewej tablicy (c) mają sie pojawic w wyniku selectu)
-- RIGHT OUTER JOIN (odwrotnie, tylko po prawej)
-- FULL JOIN (połączenie LEFT + RIGHT)


SELECT company_2.name,
       count(e.id)
FROM company_2
LEFT JOIN employee e on company_2.id = e.company_id
GROUP BY company_2.id
HAVING count(e.id) < 2;
-- Wynik uzyskany z połączenia company oraz pracownikow nalezących do tej company
-- Pogrupuj po company_id i policz ilosc pracownikow w kazdej grupie (GROUP BY)
-- Wybierz te grupy w ktorych liczna pracownikow < 2 (HAVING)

